# EventLoop和线程模型
* 线程模型概述
* 事件循环的概念和实现
* 任务调度
* 实现细节

## 线程模型
* 线程模型指定了操作系统、编程语言、框架或者应用程序的上下文中的线程管理的关键方面
* 如何以及何时创建线程将对应用程序代码的执行产生显著的影响，因此开发人员需要理解与不同模型相关的权衡
* 多线程处理是很复杂的

### 基本的线程池化模式
* 从池的空闲线程列表中选择一个 Thread，并且指派它去运行一个已提交的任务（一个Runnable 的实现）
* 当任务完成时，将该 Thread 返回给该列表，使其可被重用

## EventLoop 接口
* 运行任务来处理在连接的生命周期内发生的事件是任何网络框架的基本功能
* 与之相应的编程上的构造通常被称为事件循环
	* 一个 Netty 使用了 interface io.netty.channel.EventLoop 来适配的术语
* 两个基本的 API：并发和网络编程
* 事件/任务的执行顺序 
	* 事件和任务是以先进先出（FIFO）的顺序执行的。
	* 这样可以通过保证字节内容总是按正确的顺序被处理，消除潜在的数据损坏的可能性
* 负责处理一个Channel的整个生命周期内的所有事件

## 任务调度
* 将需要调度一个任务以便稍后（延迟）执行或者周期性地执行
* 在 Java 5 之前，任务调度是建立在 java.util.Timer 类之上的
* JDK 提供了 java.util.concurrent 包，它定义了interface ScheduledExecutorService
	* 虽然选择不是很多，但是这些预置的实现已经足以应对大多数的用例
	* 虽然 ScheduledExecutorService API 是直截了当的，但是在高负载下它将带来性能上的负担
	
### 使用 EventLoop 调度任务
* ScheduledExecutorService 的实现具有局限性，
	* 例如，事实上作为线程池管理的一部分，将会有额外的线程创建。
	* 如果有大量任务被紧凑地调度，那么这将成为一个瓶颈

## 实现细节
* 如果（当前）调用线程正是支撑 EventLoop 的线程，那么所提交的代码块将会被（直接）执行。
* 否则，EventLoop 将调度该任务以便稍后执行，并将它放入到内部队列中。
* 当 EventLoop下次处理它的事件时，它会执行队列中的那些任务/事件。
* 这也就解释了任何的 Thread 是如何与 Channel 直接交互而无需在 ChannelHandler 中进行额外同步的
* 永远不要将一个长时间运行的任务放入到执行队列中，因为它将阻塞需要在同一线程上执行的任何其他任务





