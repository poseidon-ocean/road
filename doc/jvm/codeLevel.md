# 从代码层面优化系统性能

## 问题描述
* 单台 40TPS，加到 4 台服务器能到 60TPS，扩展性几乎没有。
* 在实际生产环境中，经常出现数据库死锁导致整个服务中断不可用。
* 数据库事务乱用，导致事务占用时间太长。
* 在实际生产环境中，服务器经常出现内存溢出和 CPU 时间被占满。
* 程序开发的过程中，考虑不全面，容错很差，经常因为一个小 bug 而导致服务不可用。
* 程序中没有打印关键日志，或者打印了日志，信息却是无用信息没有任何参考价值。
* 配置信息和变动不大的信息依然会从数据库中频繁读取，导致数据库 IO 很大。
* 项目拆分不彻底，一个 Tomcat 中会布署多个项目 WAR 包。
* 因为基础平台的 bug，或者功能缺陷导致程序可用性降低。
* 程序接口中没有限流策略，导致很多 VIP 商户直接拿我们的生产环境进行压测，直接影响真正的服务可用性。
* 没有故障降级策略，项目出了问题后解决的时间较长，或者直接粗暴的回滚项目，但是不一定能解决问题。
* 没有合适的监控系统，不能准实时或者提前发现项目瓶颈。

## 优化解决方案

### 数据库死锁优化解决

* 数据库锁来说有下面三种基本锁
	* Record Lock：单个行记录上的锁
	* Gap Lock：间隙锁，锁定一个范围，但不包含记录本身
	* Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身
* 用大量的锁的目的是：防重
	* 使用 Redis 来做分布式锁
	* 使用主键防重方法，在方法的入口处使用防重表
	* 使用版本号的机制
	* 注意设置过期时间
	
### 数据库事务占用时间过长
* 示例：开启事务插入数据，在事务中间使用类似httpClient，造成长时间超时
* 使用事务的时候，遵循快进快出，事务代码尽量要小

### CPU 时间被占满分析
* private static final ExecutorService executorService = Executors.newCachedThreadPool();
* 在并发的情况下，无限制的申请线程资源造成性能严重下降
* 修改 private static final ExecutorService executorService = Executors.newFixedThreadPool(50);
* 当并发量非常大的时候，项目 GC（垃圾回收能力下降）
* 会造成大量对象堆积到队列中无法及时消费
* 方案一、将所有异步任务全部拆出应用项目，以任务的方式发送到专门的任务处理器处理，处理完成回调应用程序器
* 方案二、AKKA 

### 日志打印问题
* 首先日志的打印必须是以 logger.error 或者 logger.warn 的方式打印出来
* 日志打印格式：[系统来源] 错误描述 [关键信息]，日志信息要能打印出能看懂的信息，有前因和后果
* 在输入错误信息的时候，Exception 不要以 e.getMessage 的方式打印出来
* 避免大量无用日志记录。占用IO

### 缓存优化方案
* 缓存穿透：查询一个必然不存在的数据。比如文章表，查询一个不存在的id，每次都会访问DB，如果有人恶意破坏，很可能直接对DB造成影响。
* 缓存失效：如果缓存集中在一段时间内失效，DB的压力凸显。这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。

### 部分项目拆分不彻底
* 一个 Tomcat 中布署多个应用 war 包，彼此之间互相牵制在并发量非常大的情况下性能降低非常明显。

### 如何快速定位程序性能瓶颈
* 用 jdk 自带的命令，如 Jcmd，Jstack，jmap，jhat，jstat，iostat，vmstat 
* 用 VisualVM，MAT，JRockit 等可视化工具

### 关于索引的优化
* 索引不会包含有 NULL 值的列,复合索引中只要有一列含有 NULL值就会失效
* MySQL 索引排序
	* MySQL 查询只使用一个索引，因此如果 where 子句中已经使用了索引的话，那么 order by 中的列是不会使用索引的
	* 数据库默认排序可以符合要求的情况下不要使用排序操作
	* 尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引
	* 以下操作符可以应用索引:大于等于、Between、IN、LIKE 不以 % 开头
	* 以下操作符不能应用索引：NOT IN、LIKE %_ 开头
* 索引技巧
	* 同样是 1234567890，数值类型存储远比字符串节约存储空间。
	* 节约存储就是节约 IO，减少 IO 就是提升性能
	* 通常对数字的索引和检索要比对字符串的索引和检索效率更高。

### 使用 Redis 需要注意的一些点
* 在增加 key 的时候尽量设置过期时间，不然 Redis Server 的内存使用会达到系统物理内存的最大值，导致 Redis 使用 VM 降低系统性能
* Redis Key 设计时应该尽可能短,Value 尽量不要使用复杂对象。
* 将对象转换成 JSON 对象（利用现成的 JSON 库）后存入 Redis，
* 将对象转换成 Google 开源二进制协议对象
	* Google Protobuf，和 JSON 数据格式类似
	* 但是因为是二进制表现，所以性能效率以及空间占用都比 JSON 要小
	* 缺点是 Protobuf 的学习曲线比 JSON 大得多
* Redis 使用完以后一定要释放连接

### 关于长耗时方法的拆分
* 寻找业务的冗余点，代码中有很多重复性的代码，可以适当简化。
* 检查库表索引是否合理加入。
* 利用单元测试或者压力测试长耗时的操作进行算法级别优化，比如从库中大批量读取数据，或者长时间循环操作，或者死循环操作等等。
* 寻找业务的拆分点，根据业务需求拆分同步操作为异步，比如可以使用消息队列或者多线程异步化。
* 经过以上几个分析后如果方法执行时间仍然非常的长，这样可能就是业务方面的需求使然



引：http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650997385&idx=1&sn=f61b947f75ed4bfffe8e1d0f4d8ea005&chksm=bdbefada8ac973cc9fb86e7651105c00151e0c52c0c06caf59a56aae2eebd938cb3ee1644cda&mpshare=1&scene=1&srcid=0825rcyQR8mO7tHdmMnZUGFP#rd
http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650997473&idx=1&sn=b1ba82dea92137bc35c66af7d3d46688&chksm=bdbefab28ac973a4a5ddb46999f6d5b8e820c128c6ff9444806f6792972af5e085c2495180b3&mpshare=1&scene=1&srcid=08256shMb1CFEGPhqkKkoc1g#rd



