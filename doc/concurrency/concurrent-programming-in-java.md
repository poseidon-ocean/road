# Concurrent Programming in Java 

> 《Java 并发编程》 
>
> Doung Lea 
>
> 奥斯威戈 - 纽约州立大学 dl@cs.oswego.edu
>
> http://gee.cs.oswego.edu

## 主题

### 并发性

* Java模型，设计作用力

### 设计对象的并发

* 不变性，锁定，状态依赖，遏制，分裂

### 介绍应用并发

* 自循环，单向消息，交互式消息，注销

### 并发应用框架

* 流式，并行性，分层

### 库

* 使用、构建和记录可重用的并发类



## 关于这些幻灯片

一部分内容是基于David Holmes的陈述，澳大利亚麦考瑞大学、悉尼

更多内容来自 Addison-Wesley的《Java并发编程》

还有在线支持 http://gee.cs.oswego.edu/dl/cpj/

在线包含的素材比这本书的教程所覆盖的要多得多，他们包括额外的背景、示例和扩展

并不总是以顺序排列的

Java代码示例中会省略限定符，导入包，但完整版可以在CPJ在线找到

这些资料不是官方Sun公司的内部信息

只是Java是Sun Microsystems的注册商标



## 并发的优劣

### 优势 Why?

* 可用性Availability：尽量小的响应延迟，最大提高吞吐量
* 模块化Modelling：模拟自发对象，动画
* 并行性Parallelism：使用多处理器，重叠I/O
* 安全性Protection：独立的活跃线程

### 劣势 Why Not?

* 复杂性Complexity：处理安全、活性、组成
* 开销大Overhead：更多的资源消耗



## 通用应用

* IO密集型任务I/O-bound tasks：并发访问WEB页面、数据库、sockets...
* GUIs：并发处理事件，屏幕更新
* 托管外部代码：并发运行小应用，java组件...
* 服务守护Server Daemons：并发服务多客户端请求
* 仿真：同时模拟多个真实对象
* 通用示例：Web浏览器，web服务，数据库服务器，编程开发工具，决策支持




## 并发编程

* 并发性是软件上的概念
* 并发编程
  * might
    * 跨多核CPU处理：对称多处理器，集群，专用架构,...
    * 并行开发主要处理映射多CPU，提高性能
  * might not
    * 共享资源访问：对象、内存、显式、文件描述、sockets...
    * 分布式编程意味着并发编程不能共享系统资源
* 并发编程主要是概念和技术，即使不是并行或分布式的
  * 可在任何java平台上运行线程和相关构造
  * 本教程不会讨论特定的并行性和分布



## 并发面向对象程序设计

* 并发编程已经是OOP的一部分(since Simula67)
  * 不在OOP领域(late 1980s)
  * 最近重新出现，部分原因是Java
* 和并发OO编程不同的是
  * 串行OO编程
    * 注重安全性和活性
    * 使用和扩展通用设计模式
  * 单线程的基于事件的编程(as in GUIs)
    * 可以同时处理多个事件的发生
    * 使用扩展通用消息策略
  * 多线程系统编程
    * 封装、模块化
    * 使用扩展实现高效率



## 对象模型

* 模型描述如何思考对象（正式或非正式）
* 共同特征
  * 类，状态，引用，方法，标识，约束
  * 封装：对象内外分离
* 四个基本计算操作
  * 接受信息
  * 更新本地状态
  * 发送信息
  * 创建对象
* 模型不同于这些操作规则，主要是两类
  * 活跃的 VS 消极的
  * 并发模型包括上面两个特性
  * 独特的OO设计模式



## 主动对象模型

* message -> trigger -> anAction ->oneWay ->
* 所有对象都是同一时间单线程(like a process)处理一个事情
* 大部分`actions `是被动响应信息
  * 但`actions`可能是自发
  * 也不需要及时处理接受到的请求
* 所有消息都是单向的，其它协议可以是多路的
* 详细语义的多个扩展和选择
  * `Asynchronous vs synchronous `消息传递，排队，抢占，以及内部并发，多播通道...



## 被动对象模型

* 在顺序程序中，只有单个程序对象是活跃的
  * 被动对象作为程序的数据
* 单线程的Java，程序就是JVM(解释器)
  * 模拟对象包括顺序程序
  * 基于过程调用的所有内部通信



## 并发对象模型

* 主动与被动对象的混合
  * 正常情况下，较少的线程不是被动的对象

### 迟缓的主动对象

* 只能执行一个活动  - in Java,'run'
* 与其它线程共享大部分资源
* 需要调度好来保证共存

###灵敏的被动对象

* 可同时参与多个线程
* 保护自己不参与冲突的活动
* 与其它参与线程通信
* 启动和控制新的线程



## 硬件映射

* 共享内存多处理
  * 所有对象在同一（虚拟）机可见
  * 可使用过程消息传递
  * 通常比CPU更多线程
* 远程消息传递
  * 只能通过远程引用或复制访问对象
  * 必须汇集（序列化）消息
* 混合模型包含三层数据库仲裁



## 垂直对象（Vertical Objects）

* 大部分OO系统和应用在多个级别上运行
  * 对象在每个级别操作、管理和协调。低级别的对象作为资源
* 曾经作为一个神秘的设计原则。现在应用在大部分应用上

### 并发性Concurrency

* 线程对象也叫被动对象

### 网络与分发

* 服务器对象传递所有资源

### 持久性和数据库

* 数据库对象管理基础对象状态

### 组件框架

* 设计工具通过`JavaBean`构建应用程序，等等

### 分层应用

* 基于反射和解释的设计模式



## 设计原则

* 并发OO设计的三个主要方面
  * 策略和协议：整个系统的设计规则
  * 对象结构：设计模式，微架构
  * 编码技术：惯用语、整洁技巧、工作区
* 必须在每个方面处理的四个强制需求
  * 安全 - 完整需求
  * 活性 - 进度要求
  * 效率 - 性能需求
  * 复用 - 组合需求



## 系统 = 对象 + 行为

### 对象

* ADTs，聚合组件，JavaBeans，监控，业务对象，远程RMI对象，子系统...
* 可分组，按结构，角色，...
* 可跨多个活动使用 - 注重安全

### 行为

* 消息、调用链、多线程、会话、场景、脚本、工作流、用例、事务、数据流、移动计算...
* 可按来源、函数等分组
* 跨多个对象- 注重活动



## 安全对象

* 只在状态一致下执行方法
* 当对象短暂处于不一致状态下，通常无法预测行为的后果
  * 读/写 和 写/写会冲突
  * 不可变故障
  * 随机外部可见
* 必须平衡活跃目标
  * 客户端需要同时访问服务

## 状态不一致示例

* 一个在移动的过程中被绘制的图形
  * 可能绘制新的X值和老的Y值
  * 绘制没有出现过的位置
* 在转账期间退出银行帐号
  * 可能透支账户
  * 可能损失金钱
* 写的时候读取一个存储位置
  * 可能读取一些老的字节和一些新的字节
  * 通常，一个无意义的值

## 当前活动

* 每项活动都会执行
  * 每一个单独被调用的方法都会执行
* 相关效率
  * 每次被调用的方法必须立即执行
* 一个行为可能不能完成
  * 对象不接受的信息
  * 被阻塞的方法块，原因事件、消息或其它可能的条件，但不是另一个行为导致
  * 资源不足或不平衡
  * 各种失败或错误



## 设计二元性

两个极端途径

* 安全优先
  * 确保每一个类都是安全的，然后尽量优化活性
    * 自上而下的OO设计
    * 会导致慢，易死锁的代码
* 活性优先
  * 设计实时的底层代码，然后保证安全特征，如锁定和保护
    * 典型的多线程编程
    * 可能导致各种bug的产生
* 有效的，实用的，上面两种的结合
  * 例如，反复改进最初的设计，并保证不同环境的活性

## 保证安全

没有什么不良发生

`Nothing bad ever happens`

* 并发安全是一种延伸的安全类型
  * 增加时间纬度
  * 不完全由编译器执行
* 低水平
  * Bits 不会被混淆
  * 防止内存单元冲突：读写和写写冲突
* 高水平
  * 对象只能在一致的状态
  * 对象必须维护和代表变量状态
  * 必须显示子类




## 保证活性

最终会发送

`Something eventually happens`

* 有用性：避免不必要的阻塞
* 进程性
  * 活动中避免资源竞争
  * 避免死锁和锁定
  * 避免不公平调度
  * 容错设计、收敛性、稳定性
* 公有权
  * 尽量减少活动集的计算要求
* 防护性
  * 避免与其它程序竞争
  * 防止拒绝服务攻击
  * 防止暂停通过外部代理



## 并发与效率

* 并发可能代价高
  * 跨平台性能配置文件可能会发生变化
* 资源
  * 线程、锁、监控
* 运算
  * 建设，完成资源的开销
  * 同步，上下文切换，调度开销
* 通信
  * 交互映射到不同的CPU线程的开销
  * 缓存和位置的影响
* 效率
  * 不能使用一些快速但不安全的顺序算法
* 支付可调性和可扩展性
  * 减少特殊情况下的优化机会



## 并发性和可重用性

* 附加复杂度
  * 更严格的标准顺序代码正确性 - 通常不会自动静态检查
  * 不确定性增加了可调式性、可理解性的难度
* 附加上下文依赖（耦合）
  * 在预期的上下文中使用，仅组件安全/活性 - 需要文档
  * 可能很难扩展子类分支 - 异常继承
  * 可能很难组装 - 并发控制技术之间的冲突



## 重用和设计策略

局部思考，全局行动

`Think locally. Act globally.`

* 示例设计策略域
  * 状态依赖：无法执行请求的逻辑做什么
  * 持续服务：对并发访问方法的约束
  * 流程约束：建立消息方向性和分层规则
* 降低复杂性
  * 高级别设计规则和体系架构约束由避免不一致的具体情况决定
  * 策略很少选择‘最佳’，但通常相信规律
* 保持开放
  * 容纳任何符合给定策略的组件
  * 不遵循策略的失败不中断



## 三种可重用方法

* 设计 可重用设计技能
  * 记录最佳做饭，改进他们的本质
  * 分析安全、活性、效率、可扩展等
  * 为构建提供方案
* 框架 可重用策略和协议
  * 创建接口和类。建立应用程序套件的策略选择
  * 提供实用工具和支持类
  * 主要使用在创建应用程序依赖(分)类
* 库 可重用代码
  * 创建接口，应用在多种情况下
  * 提供高质量实现
  * 允许外部创建其它实现



## Java概述

核心Java是一个相对少且无趣的面向对象语言

* 区别于Smalltalk
  * 静态类型
  * 支持基础数据类型(int，float等)
  * 基于C的语法规则
* 区别于C++
  * 通过虚拟机运行时安全性
    * 没有安全的低级操作
    * 垃圾收集机制（GC）
  * 完全基于类，没有全局
  * 相对简单，没有多重继承等
  * 对象实现数组、字符串、类等
  * 大预定义的类库：AWT、Applets、net等




## Java特征

* Java解决的一些软件开发问题
  * 包：对象、类、组件、包
  * 移植性：字节码、unicode、传输
  * 扩展性：继承、接口、类加载
  * 安全：虚拟机、GC、检验
  * 库：java.* 包
  * 无处不在：几乎任何地方运行
* 但来自新的编程方面的挑战：
  * 并发性：线程、锁
  * 分布式：RMI、CORBA
  * 持久性：序列化、JDBC
  * 安全性：安全管理、域



## 基础Java结构

* 类： 对象特征描述
  * 实例变量： 表示对象状态的字段
  * 方法： 封装过程
  * 静态： 类变量和方法
  * 构造器： 创建对象时执行的操作
* 接口：定义任何类可实现的方法
* 继承：类对象的单一继承
* 内部类：其它类和方法中的类
* 包：组织类集的命名空间
* 可见性控制：private、public、protected、pre-package
* 修饰符：语义控制 ，final、abstract等
* 声明：类似C/C++
* 异常：失败时控制 Throw/catch
* 基本数据类型：byte、short、int、long、float、char、boolean



## 微Applet

```
import java.awt.*;
import java.applet.*;
public class ParticleApplet extends Applet {
 public void init() {
 add(new ParticleCanvas(10));
 }
}
class ParticleCanvas extends Canvas {
 Particle[] particles;
 ParticleCanvas(int nparticles) {
 setSize(new Dimension(100, 100));
 particles = new Particle[nparticles];
 for (int i = 0; i < particles.length; ++i) {
 	particles[i] = new Particle(this);
 	new Thread(particles[i]).start();
 }
 }
 public void paint(Graphics g) {
 for (int i = 0; i < particles.length; ++i)
 		particles[i].draw(g);
 }
} // (needs lots of embellishing to look nice)
```



## 微Class

```
 private int x = 0, y = 0;
 private Canvas canvas;
 public Particle(Canvas host) { canvas = host; }
 synchronized void moveRandomly() {
 x += (int) (((Math.random() - 0.5) * 5);
 y += (int) (((Math.random() - 0.5) * 5);
 }
 public void draw(Graphics g) {
 int lx, ly;
 synchronized (this) { lx = x; ly = y; }
 g.drawRect(lx, ly, 10, 10);
 }
 public void run() {
 for(;;) {
 moveRandomly();
 canvas.repaint();
 try { Thread.sleep((int)(Math.random()*10);}
 catch (InterruptedException e) { return; }
 }
 }
}
```



## Java并发支持

