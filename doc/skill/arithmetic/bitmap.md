# Bitmap算法

## 案例
* 性能优化
	* 产品经理：小灰，为了帮助公司精准定位用户群体，咱们需要开发一个用户画像系统，实现用户信息的标签化
	* 用户标签包含用户的社会属性、生活习惯、消费行为等等主要信息
	* 小灰的用户标签：程序员、男、90后、有驾照、单身、用苹果手机、从不出差、喜欢美剧、喜欢骑行、租房
	* 通过用户标签，可以实现多样用户群体统计。
		* 比如统计用户的男女比例，统计喜欢旅游的用户数量等等
* 为满足用户标签的统计需求，设计每一个纬度的标签都对应着mysql表的一列
```
name	sex		age		occupation	phone
小灰		男		90后		程序员		苹果
大黄		男		90后		程序员		苹果
小白		女		00后		学生			小米
```
* 统计所有90后的程序员：
	* SELECT COUNT(DISTINCT name) AS 用户数 FROM table_name	WHERE age = '90后' AND occupation = '程序员';
* 统计所有使用苹果手机或者00后的用户总和
	* SELECT COUNT(DISTINCT name) AS 用户数 FROM table_name	WHERE phone = '苹果' OR age = '00后';
* 标签越来越多，都快上千了，这得要多少列
	* 筛选标签过多的时候，拼接出来的SQL语句像面条一样长
	* 多用户群体求并集的时候要做distinct，性能实在太慢了

## bitmap算法 - 位图算法
* 位图是Windows标准格式图形文件，它将图像定义为由点（像素）组成，每个点可以由多种色彩表示，包括2、4、8、16、24和32位色彩
* 这里所说的位图不是像素图片，而是内存中连续的二进制位(bit)，用于对大量整型数据做去重和查询
* 示例：给定一个长度是10bit的内存空间，想要依次插入整型数据4,3,2,1，需要怎么做
	* 1.给定长度是10的bitmap，每一个bit位分别对应着从0到9的10个整型数，此时bitmap的所有位都是0
	* 2.把整型数4存入bitmap，对应存储的下标位置为1
	* 3.把整型数2存入bitmap，对应存储的位置就是下标为2的位置，将此bit置为1
	* 4.把整型数1存入bitmap，对应存储的位置就是下标为1的位置，将此bit置为1
	* 5.把整型数3存入bitmap，对应存储的位置就是下标为3的位置，将此bit置为1
	* 此时bitmap里存储了4,3,2,1，一目了然
* bitmap不仅方便查询，还可以去除重复掉的整型数

## 用户标签能不能用bitmap的形式来存储
* 为什么一定要一个用户对应多个标签，而不是一个标签对应多个用户呢？
* 可以先建立一个用户名和用户ID的映射，然后让每一个标签存储包含此标签的所有用户的ID
* 1.建立用户名和用户ID的映射
```
name	sex		age		occupation	phone
小灰		男		90后		程序员		苹果
大黄		男		90后		程序员		苹果
小白		女		00后		学生			小米
```
==》
```
id	name	
1	小灰		
2	大黄		
3	小白		
```
* 2.让每一个标签存储包含此标签的所有用户ID，每一个标签都是一个独立的Bitmap
```
id		sex		age		occupation	phone
1		男		90后		程序员		苹果
2		男		90后		程序员		苹果
3		女		00后		学生			小米
```
==>
```
sex		bitmap		|	age		bitmap	
男		1,2				90后		1,2
女		3				00后		3
```
```
occupation		bitmap		|	phone		bitmap	
程序员			1,2				苹果			1
学生				3				三星			2
								小米			3
```
* 3.这样，实现用户的去重和查询统计，就变得一目了然	
	* 程序员：1,2
	* 00后：3

## HashSet和HashMap也能实现用户的去重和统计，为什么一定要用Bitmap？
* 如果用HashSet和HashMap存储的话，每一个用户ID都要存成int，占4字节即32bit
* 而一个用户在Bitmap中只占一个bit，内存节省了32倍
* Bitmap在用户群做交集和并集运算的时候也有极大的便利：位运算的高性能
* 如何查找使用苹果手机的程序员用户
	* 程序员用户(1,2) 00000000110B 
	* 使用苹果手机的用户(1) 0000000010B
	* 使用苹果手机的程序员(00000000110B & 0000000010B=0000000010B)
* 如何查找所有男性或者00后的用户
	* 男性用户 0000000110B
	* 00后用户 0000001000B
	* 男性或00后用户 (0000000110B | 0000001000B = 0000001110B)
* JDK中BitSet集合是对Bitmap算法相对简单的实现
* 谷歌开发的EWAHCompressedBitmap则是一种更为优化的实现

## Bitmap的缺点：不支持非运算
* 90后用户 0000000110B， 非90后用户1111111001B
* 非90后用户实际上只有1个，而不是得到的8个结果，所以不能直接进行非运算。
* 若一定要求出不属于某个标签的用户数量，该怎么办
	* 需借助一个全量的Bitmap
	* 90后用户 0000000110B
	* 全量用户 0000001110B
	* 使用异或操作，即相同位为0，不同位为1 (0000000110B XOR 0000001110B = 0000001000)
	
## 空间优化
* 如果一个很长的Bitmap里只存一两用户，那样岂不是浪费空间
* 谷歌的EWAHCompressedBitmap中，对Bitmap存储空间做了一定的优化
* EWAHCompressedBitmap的存储方式
	* 存储于long数组当中
	* long数组的每一个元素都可以当做是64位的二进制数，也是整个Bitmap的子集[Word]
	* 当创建一个空的Bitmap时，初始只有4个Word，也即long数组的长度是4
		* 随着数据的不断插入，Word数量会随之扩充
		* word0、word1、word2、word3
		* word0不直接存储数据，姑且认为它存储的是Bitmap的头信息
* 两个概念
	* 直接存储数据的叫Literal Word(LW)	
	* 存储[跨度信息]的叫Running Length Word.[RLW]
* 每一个RLW分成两部分，低32位表示当前Word横跨了多少个空word，高32位表示当前RLW后方有多少个连续的LW
* 对于极端稀疏的Bitmap，这样节省了大量的空间

## 正确存储
* 有些word存储数据，有些word存储跨度信息，当一个新数据插入的时候，如何找到正确的位置呢？
* 要依靠每一个RLW作为路标，比如要插入的新ID是400003，寻找位置过程：
	* 1.解析word0，得知当前RLW横跨的空word数量为0，后面有连续3个普通word
	* 2.计算出当前RLW后方连续普通word的最大ID是 64 X (0+3)-1=191
	* 3.由于191 < 400003，所以新ID必然在下一个RLW(word4)之后
	* 4.解析word4，得知当前RLW横跨的空word数量为6247，后面有连续1个普通word
	* 5.计算当前RLW(word4)后方连续普通word的最大值ID是191 + (6247+1 X 64)=400063
	* 6.由于400003<400063，因此新ID 400003的正确位置就在当前RLW(word4)的后方普通word，也就是word5当中
* 如果新插入的ID刚好在存储横跨信息的RLW范围之内，比如插入200000，该怎么办
	* 涉及原RLW分裂，如插入200000：横跨6247个word -- 横跨3122个word + word + 横跨3124个word
	* 在RLW中间插入数值的时候，会涉及到部分word的移位，影响性能，官方建议使用者从小到大来插入数据

```
EWAHCompressedBitmap对应的maven依赖如下：

<dependency>
  <groupId>com.googlecode.javaewah</groupId>
  <artifactId>JavaEWAH</artifactId>
  <version>1.1.0</version>
</dependency>
```



> http://mp.weixin.qq.com/s/xxauNrJY9HlVNvLrL5j2hg