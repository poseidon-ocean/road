# 垃圾收集器与内存分配策略
* Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的"高墙"，墙外面的人想进去，墙里面的人却想出来

## 概述
* 垃圾收集器(Garbage Collection)GC
* 1960年诞生于MIT的Lisp是一门真正的使用内存动态分配和垃圾收集技术的语言
* 思考GC需要完成的3件事：
	* 哪些内存需要回收
	* 什么时候回收
	* 如何回收
* 为什么需要了解GC和内存分配？
	* 但需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对这些“自动化”的技术实施必要的监控和调节
	
## 对象已死吗
* 第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）

### 引用计数算法
* 很多教科书判断对象是否存活的算法：
	* 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；
	* 当引用失效时，计数器值就减1
	* 任何时刻计数器为0的对象就是不可能再被使用的
* 引用计数法(Reference Counting)的实现简单，判定效率高，案例：
	* 微软的COM(Component Object Model)技术
	* 使用ActionScript 3的FlashPlayer
	* Python 语言和在游戏脚本领域被广泛应用的Squirrel
* 主流Java虚拟机里面没有选用引用计数算法来管理内存。主因：它很难解决对象间相互循环引用的问题

### 可达性分析算法
* 主流程序语言的主流实现，都是通过可达性分析(Reachability Analysis)来判定对象是否存活
* 基本思路：
	* 通过一系列称为“GC Roots”的对象作为起始点
	* 从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)
	* 当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的
* Java语言，可作为GC Roots的对象包括：
	* 虚拟机栈(栈帧的本地变量表)中引用的对象
	* 方法区中类静态属性引用的对象
	* 方法区中常量引用的对象
	* 本地方法栈中JNI(即一般说的Native方法)引用的对象

### 再谈引用
* 引用计数算法和可达性分析算法，判定对象是否存活都与“引用”有关
* JDK1.2以前，引用的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用
* 一个对象在这种定义下只有被引用或者没有被引用两种状态，对于描述“食之无味，弃之可惜”的对象就显得无能为力
* 希望：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可抛弃这些对象（缓存）
*　JDK1.2之后，引用分
	* 强引用(Strong Reference)
	* 软引用(Soft Reference)
	* 弱引用(Weak Reference)
	* 虚引用(Phantom Reference)
	* 引用强调依次减弱
* 强引用，类似“Object obj = new Object()”，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象
* 软引用是用来描述一些还有用但并非必需的对象，这类对象在系统将要发生内存溢出异常之前，将会把这些对象列回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出异常，在JDK1.2之后，提供了SoftReference类来实现软引用
* 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用
* 虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用

### 生存还是死亡
* 即使在可达性分析算法中不可达的对象，也并非是“非死不可”，此时暂处“缓刑”阶段
* 真正宣告一个对象死亡，至少要经历两次标记过程：
	* 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选
		* 筛选的条件是此对象是否有必要执行finalize()方法
		* 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”
		* 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫F-Queue的队列之中
		* 稍后由一个虚拟机自动建立、低优先级的Finalizer线程去执行它
		* finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记
		* 如果对象要在finalize()中成功拯救自己
			* 只有重新与引用链上的任何一个对象建立关联即可
			* 如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那第二次标记时它将被移除出“即将回收”的集合
			* 如果对象这时还没有逃脱，那基本上就真的被回收了

### 回收方法区
* 很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的
* Java虚拟机规范确实说过可以不要求虚拟机在方法区实现垃圾收集
* 在方法区中进行垃圾收集的“性价比”一般比较低
* 在堆中，尤其在新生代中，常规应用进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率远低于此
* 永久代的垃圾收集：废弃常量和无用的类
* 判定废弃常量
	* 回收废弃常量与回收Java堆中的对象类似
	* 如常量池中的字面量的回收，字符串“abc”进入常量池，没有任何String对象引用常量池中的“abc”常量，这个常量就会被系统清理出常量池
	* 常量池中的其它类(接口)、方法、字段的符号引用也类似
* 判定无用类
	* 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
	* 加载该类的ClassLoader已经被回收
	* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
* 是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制
	* 可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息
	* 大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出

## 垃圾收集算法
* http://www.cnblogs.com/ityouknow/p/5614961.html

## HotSpot的算法实现
* 在HotSpot虚拟机上实现对象存活判定算法和垃圾收集算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行

### 枚举根节点
* 可作为GC Roots的节点主要在全局性的引用（常量或类静态属性）与执行上下文（帧栈中的本地变量）中，弱逐个检查里面的引用，必然消耗很多时间
* 可达性分析对执行时间的敏感还体现在GC停顿上，因为必须确保一致性的快照中进行
	* 一致性是指在整个执行系统看起来像被冻结在某个时间节点
	* 这点会导致GC进行时必须停顿所有Java执行线程(Stop the World)
	* 即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的
* 主流Java虚拟机使用的都是准确式GC
	* 当执行系统停顿下来时，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用
	* 在HotSpot的实现中，是使用一组称为OoMap的数据结构来达到目的
		* 在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来
		* 在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用
		* 这样，GC在扫描时可以直接得知这些信息

### 安全点 SafePoint
* 在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举
* 问题：如果每一天指令都对应OopMap，需要大量的额外空间，导致GC空间成本变高
* 实际，HotSpot也没有为每条指令生成OopMap，只是在特定的位置记录了这些信息，这些位置称为安全点
* 程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能停顿
* SafePoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以至于过分增大运行时的负荷
* 安全点的选定：是以程序“是否具有让程序长时间执行的特征”为标准
* 每条指令执行时间都非常短暂，程序不太可能因为指令流长度太长这个原因而长时间运行
* “长时间执行”的最明显特征就是指令序列复用：方法调用、循环跳转、异常跳转，具有这样功能的指令才会生成SafePoint
* 另一个问题是如何在GC发生时让所有线程都“跑”到最近的安全点再停顿下来
	* 抢先式中断(Preemptive Suspension)：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点，就恢复线程，让它跑到安全点上，几乎没有虚拟机实现这种方式
	* 主动式中断(Voluntary Suspension)：当GC需要中断线程的时候，不直接对线程操作，仅简单设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起
		* 轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方
		
### 安全区域 Safe Region
* SafePoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的SafePoint
* 如程序不执行呢？程序不执行是没有分配CPU时间，如线程处于Sleep和Blocked状态
* 线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也不太可能等待时间重新分配CPU时间，这种情况需求安全区域来解决
* 安全区域是指在一段代码片段之中，引用关系不会发生变化，在这个区域中的任何地方开始GC都是安全的
* 当线程执行到Safe Region中的代码时，首先标识自己已经进入Safe Region
	* 当这段时间内JVM要发起GC时，不用管标识为Safe Region状态的线程
	* 当线程要离开Safe Region时，要检查系统是否已经完成了根节点枚举（或者整个GC过程）
	* 如果完成了，那线程就继续执行，否则就必须等待直到收到可以安全离开Safe Region的信号为止
* 上面介绍了HotSpot虚拟机如何发起内存回收的问题，内存回收如何进行是由虚拟机所采用的GC收集器决定的

## 垃圾收集器
* 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现
* http://www.cnblogs.com/ityouknow/p/5614961.html
* 并行（Parallel）：指多条垃圾收集器并行工作，但此时用户线程仍然处于等待状态
* 并发（Concurrent）：指用户线程与垃圾收集器线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上

### 理解GC日志
* 阅读GC日志是处理Java虚拟机内存问题的基础技能
* 每一种收集器的日志形式都是由它们自身的实现所决定的
```
[GC (System.gc()) [PSYoungGen: 5735K->798K(18944K)] 5735K->806K(62976K), 0.0012461 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (System.gc()) [PSYoungGen: 798K->0K(18944K)] [ParOldGen: 8K->692K(44032K)] 806K->692K(62976K), [Metaspace: 2593K->2593K(1056768K)], 0.0061717 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 18944K, used 164K [0x00000000eb180000, 0x00000000ec680000, 0x0000000100000000)
  eden space 16384K, 1% used [0x00000000eb180000,0x00000000eb1a90d0,0x00000000ec180000)
  from space 2560K, 0% used [0x00000000ec180000,0x00000000ec180000,0x00000000ec400000)
  to   space 2560K, 0% used [0x00000000ec400000,0x00000000ec400000,0x00000000ec680000)
 ParOldGen       total 44032K, used 692K [0x00000000c1400000, 0x00000000c3f00000, 0x00000000eb180000)
  object space 44032K, 1% used [0x00000000c1400000,0x00000000c14ad3f8,0x00000000c3f00000)
 Metaspace       used 2599K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 286K, capacity 386K, committed 512K, reserved 1048576K
```
* 最前面的数字“33.125: ”代表GC发生的时间，含义是Java虚拟机启动以来经过的秒数
* GC日志开头“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型
	* 有Full，说明这次GC是发生了Stop-The-World
	* 如果是调用System.gc()方法所触发的收集，显示[Full GC (System.gc())
* [GefNew、[Tenured、[Prem表示GC发生的区域
* 方括号内部 5735K->798K(18944K)含义是GC前该内存区域已使用容量 -> GC后该内存区域已使用容量(该区域内存总容量)
* 方括号外部 5735K->806K(62976K)含义是GC前Java堆已使用容量 -> GC后Java堆已使用容量(Java堆总容量)
*  0.0012461 secs 表示内存区域GC所占用的时间，单位是秒
* [Times: user=0.00 sys=0.00, real=0.00 secs] 更具体的时间数据
	* 用户动态消耗的CPU时间
	* 内核态消耗的CPU时间
	* 操作从开始到结束所经过的撞钟时间(Wall Clock Time)
* CPU时间与撞钟时间的区别
	* 撞钟时间包括各种非运算的等待耗时，如等待磁盘I/O、等待线程阻塞
	* CPU不包含以上时间，多核CPU时间会叠加

## 内存分配与回收策略
* 自动内存管理解决了两个问题：给对象分配内存以及回收分配给对象的内存
* 对象的内存分配
	* 在堆上分配，也可能经过JIT编译后被拆散为标量类型并间接地栈上分配
	* 对象主要分配在新生代Eden区上，如果启动了本地线程的分配缓存，将按线程优先在TLAB上分配
	* 少数可能直接分配在老年代中
	* 分配规则取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置

### 大对象优先在Eden分配
* 对象在新生代Eden区中分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC
* 收集器日志参数：-XX:+PrintGCDetails，告诉虚拟机在发送垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况
* Minor GC和Full GC有什么不一样？
	* 新生代GC(Minor GC)：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快
	* 老年代GC(Major GC/Full GC)：指发生在老年代的GC，出现了Major GC，经常会伴随出现至少一次的Minor GC(但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)，Major GC的速度一般会比Minor GC慢10倍以上
	
### 大对象直接进入老年代
* 大对象是指，需要大量连续内存空间的Java对象，如很长的字符串以及数组
* 大对象对虚拟机的内存分配来说就是一个坏消息，经常出现容易导致内存还有不少空间时就提前触发垃圾收集
	* 更坏的情况是 短命的大对象，写程序应该避免
* 参数：-XX:PretenureSizeThreshold，令大于这个设置值的对象直接在老年代分配，避免在Eden区和两个Survivor区之间发生大量的内存复制
	* 只对Serial和ParNew收集器有效
	* Parallel Scavenge收集器不认识这个参数，也不需要设置
	* 应用场合：ParNew和CMS组合

### 长期存活的对象将进入老年代
* 虚拟机采用分代收集的思想管理内存，内存回收如何识别哪些对象存放在新生代，哪些对象存放在老年代
	* 虚拟机给每个对象定义了一个对象年龄(Age)，如果对象在Eden区出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移到Survivor空间，年龄设置为1
	* 对象在Survivor区每熬过一次Minor GC，年龄加1，当年龄增加到一定程度(默认15)，就将会晋升到老年代
		* 晋升老年代阀值参数：-XX:MaxTenuringThreshold

### 动态对象年龄判定
* 为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象达到了MaxTenuringThreshold才晋升到老年代
* 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代

### 空间分配担保











	
	
	
> 别老是劝自己注重长远利益，短平快的小目标积累下来，那才能真正的长远。
知到极处便是行，行到极处便是知
你只所以熬夜，是因为你的意识深处在惩罚你今天丝毫没有进步，没有任何经验和阅历的上升