# Java内存区域与内存溢出异常

## 运行时数据区域
* Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域
	* 这些区域有各自的用途，以及创建和销毁的时间
	* 有的区域随着虚拟机进程的启动而存在
	* 有些区域则依赖用户线程的启动和结束而建立和销毁
	
### 程序计数器
* 程序计数器(Program Counter Register)是一块较小的内存空间，可看作当前线程所执行的字节码的行号指示器
	* 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
	* 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
* Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的
	* 在任何一个确定的时刻，一个处理器（对于多核处理器来说就是一个内核），都只会执行一条线程中的指令
	* 为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器
	* 各条线程之间计数器互不影响，独立存储，这类内存区域是线程私有的内存
* 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址
* 如果正在执行的是Native方法，这个计数器值则为空(Undefined)
* 此内存区域是惟一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域

### Java虚拟机栈
* Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，生命周期与线程相同
* 虚拟机栈描述的是Java方法执行的内存模型：
	* 每个方法在执行的同时都会创建一个栈帧(Stack Frame)
	* 用于存储局部变量表、操作数栈、动态链接、方法出口等信息
	* 每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程
* 局部变量表存放了
	* 编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)
	* 对象引用(reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其它与此对象相关的位置)
	* returnAddress类型(指向了一条字节码指令的地址)
* 64位长度的long和double类型的数据会占用2个局部变量空间(slot)，其余的数据类型只占用1个
* 局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小
* 在Java虚拟机规范中，对这个区域规定了两种异常状况
	* 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常
	* 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，将会抛出OutOfMemoryError异常
* 大部分发Java虚拟机都可以动态扩展，只不过Java虚拟机规范中也允许规定长度的虚拟机
* 栈帧是方法运行时的基础数据结构

### 本地方法栈
* 本地方法栈(Native Method Stack)与虚拟机栈作用相似
* 区别：
	* 虚拟机栈为虚拟机执行Java方法(也就是字节码)服务
	* 本地方法栈则为虚拟机使用到的Native方法服务
* 也会抛出StackOverflowError和OutOfMemoryError异常

### Java堆
* 大多数应用，Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块
* 被所有线程共享的一块内存区域，在虚拟机启动时创建
* 此内存区域唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存
* Java虚拟机规范描述：
	* 所有的对象实例以及数组都要在堆上分配
	* 随着JIT编译器发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有对象都分配在堆上也不那么绝对了
* Java堆是垃圾收集器管理的主要区域，也称"GC堆"(Garbage Collected Heap)
* 从内存回收看，由于收集器基本采用分代收集算法，可细分：新生代和老年代
* 从内存分配看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)
* 无论如何划分，都与存放内容无关，存储的都是对象实例
* 进一步划分的目的是为了更好地回收内存或更快的分配内存
* 当前主流虚拟机都是按照可扩展来实现的，通过-Xmx和-Xms控制
* 如果在堆中没有内存完成实例分配，并且堆也无法扩展时将会抛出OutOfMemoryError异常

### 方法区(Method Area)
* 与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态常量、及时编译器编译后的代码数据
* Java虚拟机规范把方法区描述为堆的一个逻辑部分，但有个别名Non-Heap(非堆)，目的是与Java堆区分开来
* 根据Java虚拟机规范，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常

### 运行时常量池(Runtime Constant Pool)
* 是方法区的一部分，受方法区内存限制，当常量无法再申请到内存时会抛出OutOfMemoryError异常
* Class文件中除了有类的版本、字段、方法、接口等描述信息，还有一项信息是常量池(Constant Pool Table)
* 用于存放编译生成的各种字面量和符号引用，将在类加载后进入方法区的运行时常量池中存放
* 具备动态性，运行期间也可能将新的常量放入池中

### 直接内存(Direct Memory)
* 不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域，若被频繁使用，也可能导致OutOfMemoryError异常
* NIO类，引入一种基于通道Channel与缓冲区Buffer的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffter对象为这块内存引用进行操作
* 不受Java堆大小的限制，内存还是会受本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制
* 服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个区域内存总和大于物理内存限制（包括物理的和操作系统的限制），从而导致动态扩展时出现OutOfMemoryError异常

## HotSpot虚拟机对象探秘

### 对象的创建
* 语言层面，创建对象(如克隆、反序列化)通常仅是一个new关键字
* 虚拟机中对象的创建：
	* 遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用
	* 并且检查这个符号引用代表的类是否已被加载、解析和初始化过
	* 如果没有必须先执行相应的类加载过程
	* 在类加载检查通过后，虚拟机将会为新生对象分配内存
		* 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个空指针作为分界点的指示器，那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为"指针碰撞"(Bump the Pointer)
		* 如果Java堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为"空闲列表"(Free List)
		* 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
		* 使用Serial、ParNew等带Compact过程的收集器，系统采用的分配算法是指针碰撞
		* 使用CMS这种基于Mark-Sweep算法的收集器，通常采用空闲列表
* 一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行为
	* 即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的
	* 可能出现正在给A对象分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存
	* 解决这个问题的方案：
		* 一种是对分配内存空间的动作进行同步处理-实际上虚拟机采用CAS配上失败重试的方式来保证更新操作的原子性
		* 一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配以小块内存，称为本地线程分配缓冲(TLAB)
			* 哪个线程要分配内存，就在哪个线程的TLAB上分配
			* 只有TLAB用完并分配新的TLAB时，才需要同步锁定
			* 虚拟机是否使用TLAB，可以通过-XX:+/-UserTLAB参数来设定
* 内存分配完成后，虚拟机需要将分配的内存空间都初始化为零值(不包括对象头)
* 接下来，虚拟机要对对象进行必要的设置：
	* 这个对象是哪个类的实例
	* 如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象头(Object Header)
	* 根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式
* 上面工作完成之后，new指令之后会接着执行<init>指令，初始化完成对象才算真正创建完毕

### 对象的内存布局
* HotSpot虚拟机，对象内存存储布局：对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)
* HotSpot虚拟机的对象头包括两部分信息：
	* 第一部分用于存储对象自身的运行时数据
		* 运行时数据：哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳，官方称Mark Word
		* Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽可能多的信息
	* 另一部分是类型指针，即对象指向它的类元数据的指针
* 实例数据部分是对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容
	* 存储顺序会受到虚拟机分配策略参数(FieldsAllocationStyle)和字段在Java源码中定义顺序的影响
	* HotSpot虚拟机默认的分配策略：longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)
	* 相同宽度的字段总是被分配到一起
* 对齐填充不是必然的，仅仅起着占位符的作用：对象的大小必须是8的整数倍，对象实例没有对齐时需要通过对齐填充来补全

### 对象的访问定位
* 建立对象是为了使用对象，程序需要通过栈上的references数据来操作堆上的具体对象
* Java虚拟机规范只规定references类型一个指向对象的引用，没有规定这个引用应该通过何种方式去定位、访问堆中对象的具体位置
* 访问对象方式取决于虚拟机实现而定，主流的访问方式使用句柄和直接指针句柄
	* 使用句柄访问：Java堆划分一块内存作为句柄池，references中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息
	* 直接指针访问：Java堆对象的布局就必须考虑如何放置访问类型数据的相关信息，而references中存储的直接就是对象地址
	* 使用句柄访问好处是references中存储的是稳定的句柄地址，对象被移动时只会改变句柄的实例数据，不需要修改references本身
	* 直接指针访问好处是速度快。由于对象的访问十分频繁，这类开销积少成多也是一项非常可观的执行成本

## 实战：OutOfMemoryError异常
* 在Java虚拟机规范描述中，除程序计数器外，虚拟机内存的其他运行区域都有发生OutOfMemoryError异常的可能
* 本节内容的目的：
	* 通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容
	* 在工作中遇到实际的内存溢出异常时，能根据异常的信息快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现这些异常后该如何处理
* 虚拟机启动参数对实验的结果有直接的影响
	* 控制台执行，在Java命令后书写
	* IDE 在Debug/Run页签中设置

### Java堆溢出 com.leaf.u_jvm.HeapOOM
* Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常 

### 虚拟机栈和本地方法栈溢出 JavaVMStackOOM
* 在HotSpot虚拟机中不区分虚拟机栈和本地方法栈
* 对HotSpot来说，虽然设置-Xoss参数(设置本地方法栈大小)存在，但实际是无效的，栈容量只由-Xss参数设定
* 关于虚拟机栈和本地方法栈，Java虚拟机规范描述了两种异常：
	* 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常
	* 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常
* 在单线程下，无论是由于栈帧太小还是虚拟机容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常

### 方法区和运行时常量池溢出
* 运行时常量池是方法区的一部分
* String.intern()是Native方法，作用：如果字符串常量池中包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用
* 从JDK7开始逐步去永久代
* 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等
	* 对于这些区域的测试。基本思路是运行时产生大量的类去填满方法区，直到溢出
	* 可以直接使用Java SE API动态产生类(如反射的GenerateConstructor和动态代理)
	* 也可借助CGLib直接操作字节码运行时生成大量的动态类
* 方法区溢出是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判断条件是比较苛刻的
	* 在经常动态生成大量Class的应用中，需要特别注意；类的回收状况
	* 主流框架：如Spring、Hibernate对类进行增强，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存
	* JVM的动态语言(Groovy)通常都会持续创建类来实现语言的动态性
	* 大量JSP或动态产生JSP文件的应用
	* 基于OCGI的应用

### 直接内存溢出
* DirectMemory容量可通过-XX:MaxDirectMemory指定，如果不指定，则默认与Java堆最大值(-Xmx指定)一样
* 由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因




## CAS：Compare And Swap
* 现代CPU支持的一种对内存中共享数据进行操作的一种特殊指令，会对内存的共享数据做原子的读写操作
* 操作过程：
	* 首先，CPU会将内存中将要更改的数据与期望的值做比较。
	* 然后，当这两个值相等时，CPU才会将内存中的数值替换为新的值，否则便不做操作
	* 最后，CPU会将旧的数值返回，这一系列的操作是原子的
* CAS的含义：我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少
* CAS有三个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V
* CAS是一种乐观锁，相信在它修改之前，没有其它线程去修改它
* Synchronized是一种悲观锁，它认为在它修改之前，一定会有其它线程去修改它，悲观锁效率很低
* CAS的ABA问题：https://en.wikipedia.org/wiki/ABA_problem



> 人与人之间需要相互尊重、相互信任、而不是相互托付
真正的勇者应该是在这个绝望的世界里优雅地活着的。
人际成熟的人，永远不要假设对方“开得起玩笑”。开玩笑如果不避开对方的短处，那叫讥讽。
冷读术，就是在简单了解的基础上，用主动的语言或行为，表达对他人的理解。


